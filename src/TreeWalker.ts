/**
 * @module compiler/main
 */

/**
 * indicative-compiler
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

import { ParsedSchema, SchemaNodeLiteral, SchemaNodeObject, SchemaNodeArray } from 'indicative-parser'
import { ConsumerFn, ArrayWrapper } from './contracts'

/**
 * Tree walker is an agnostic implementation to walk over the parsed schema
 * tree generated by `indicative-parser`.
 *
 * The consumer of the code can define a function to consumer the tree nodes and
 * define another function to wrap the children of an array node.
 *
 * ## Why wrap array children?
 * Since the length of an array is unknown, until we receive the data at
 * runtime, we need a parent function (aka wrapper), that can execute
 * the child validations as per the length of the array.
 *
 * ```js
 * function consumerFn (field: string, rules: ParsedRule[], dotPath: string[], pointer: string) {
 * }
 *
 * function arrayWrapper (
 *   index: string,
 *   field: string,
 *   children: ReturnType<consumerFn>[],
 *   dotPath: string[],
 * ) {
 * }
 *
 * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)
 * ```
 */
export class TreeWalker<T extends any = any, U extends any = any> {
  constructor (private _consumerFn: ConsumerFn<T>, private _arrayWrapper: ArrayWrapper<T, U>) {
  }

  /**
   * Processes the literal node inside schema tree
   */
  private _processLiteralNode (
    field: string,
    node: SchemaNodeLiteral,
    dotPath: string[],
    arrayPath: string[],
  ): T {
    const pointer = arrayPath.concat(dotPath).concat(field).join('.')
    return this._consumerFn(field, node.type, node.rules, dotPath, pointer)
  }

  /**
   * Process the object node inside the parsed. All children are parsed recursively
   */
  private _processObjectNode (
    field: string,
    node: SchemaNodeObject,
    dotPath: string[],
    arrayPath: string[],
  ): (T | U)[] {
    let output: ReturnType<ConsumerFn>[] = []

    /**
     * If object itself has rules, then we need to consume that
     * as well.
     */
    if (node.rules.length) {
      const pointer = arrayPath.concat(dotPath).concat(field).join('.')
      output.push(this._consumerFn(field, node.type, node.rules, dotPath, pointer))
    }

    /**
     * Walker over object children
     */
    output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath))
    return output
  }

  /**
   * Process the array node of the schema tree. This method will call the `arrayWrapper`
   * function and passes all array children to it.
   */
  private _processArrayNode (
    field: string,
    node: SchemaNodeArray,
    dotPath: string[],
    arrayPath: string[],
  ): (T | U)[] {
    let output: ReturnType<ConsumerFn>[] = []

    const basePath = arrayPath.concat(dotPath).concat(field)

    /**
     * If array itself has rules, then we need to process that
     * as well
     */
    if (node.rules.length) {
      const pointer = basePath.join('.')
      output.push(this._consumerFn(field, node.type, node.rules, dotPath, pointer))
    }

    /**
     * Processing children for each index. The index of the tree can be a wildcard
     * `*`, which means we rely on runtime data to know the actual length of
     * the array.
     */
    Object.keys(node.each).forEach((index) => {
      let child: (T | U)[] = []

      if (node.each[index].rules.length) {
        const pointer = basePath.concat(index).join('.')
        child.push(this._consumerFn('::tip::', 'literal', node.each[index].rules, [], pointer))
      }

      child = child.concat(this.walk(node.each[index].children, [], basePath.concat(index)))
      output = output.concat(this._arrayWrapper(index, field, child, dotPath))
    })

    return output
  }

  /**
   * Walks the schema tree and invokes the `consumerFn` for each node. The output
   * of the consumer is collected and returned back as an array.
   */
  public walk (schema: ParsedSchema, dotPath: string[] = [], arrayPath: string[] = []): (T | U)[] {
    return Object.keys(schema).reduce((result: (T | U)[], field) => {
      const node = schema[field]
      if (node.type === 'literal') {
        result = result.concat(this._processLiteralNode(field, node, dotPath, arrayPath))
      }

      if (node.type === 'object') {
        result = result.concat(this._processObjectNode(field, node, dotPath, arrayPath))
      }

      if (node.type === 'array') {
        result = result.concat(this._processArrayNode(field, node, dotPath, arrayPath))
      }

      return result
    }, [])
  }
}
