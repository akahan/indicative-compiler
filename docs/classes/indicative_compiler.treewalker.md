[indicative-compiler](../README.md) > [indicative-compiler](../modules/indicative_compiler.md) > [TreeWalker](../classes/indicative_compiler.treewalker.md)

# Class: TreeWalker

Tree walker is an agnostic implementation to walk over the parsed schema tree generated by `indicative-parser`.

The consumer of the code can define a function to consumer the tree nodes and define another function to wrap the children of an array node.

Why wrap array children?
------------------------

Since the length of an array is unknown, until we receive the data at runtime, we need a parent function (aka wrapper), that can execute the child validations as per the length of the array.

```js
function consumerFn (field: string, rules: ParsedRule[], dotPath: string[], pointer: string) {
}

function arrayWrapper (
  index: string,
  field: string,
  children: ReturnType<consumerFn>[],
  dotPath: string[],
) {
}

new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)
```

## Type parameters
#### T :  `any`
#### U :  `any`
## Hierarchy

**TreeWalker**

## Index

### Constructors

* [constructor](indicative_compiler.treewalker.md#constructor)

### Methods

* [walk](indicative_compiler.treewalker.md#walk)

---

## Constructors

<a id="constructor"></a>

###  constructor

⊕ **new TreeWalker**(_consumerFn: *[ConsumerFn](../modules/indicative_compiler.md#consumerfn)<`T`>*, _arrayWrapper: *[ArrayWrapper](../modules/indicative_compiler.md#arraywrapper-1)<`T`, `U`>*): [TreeWalker](indicative_compiler.treewalker.md)

**Parameters:**

| Name | Type |
| ------ | ------ |
| _consumerFn | [ConsumerFn](../modules/indicative_compiler.md#consumerfn)<`T`> |
| _arrayWrapper | [ArrayWrapper](../modules/indicative_compiler.md#arraywrapper-1)<`T`, `U`> |

**Returns:** [TreeWalker](indicative_compiler.treewalker.md)

___

## Methods

<a id="walk"></a>

###  walk

▸ **walk**(schema: *`ParsedSchema`*, dotPath?: *`string`[]*, arrayPath?: *`string`[]*): (`T` \| `U`)[]

Walks the schema tree and invokes the `consumerFn` for each node. The output of the consumer is collected and returned back as an array.

**Parameters:**

| Name | Type | Default value |
| ------ | ------ | ------ |
| schema | `ParsedSchema` | - |
| `Default value` dotPath | `string`[] |  [] |
| `Default value` arrayPath | `string`[] |  [] |

**Returns:** (`T` \| `U`)[]

___

